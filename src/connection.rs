use crate::*;

use core::{default, ops::Not};
use std::{collections::HashMap, dbg, println, string::ToString, vec::Vec};
extern crate alloc;
use alloc::string::String;
use std::vec;
use storage_endian::BigEndian;
use ubuserror::*;

#[derive(Copy, Clone)]
pub struct ObjectResult<'a> {
    pub path: &'a str,
    pub id: u32,
    pub ty: u32,
}
impl core::fmt::Debug for ObjectResult<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(f, "{} @0x{:08x} type={:08x}", self.path, self.id, self.ty)
    }
}

pub struct SignatureResult<'a> {
    pub object: ObjectResult<'a>,
    pub name: String,
    pub args: HashMap<String, BlobMsgType>,
}

#[derive()]
pub struct Connection<T: AsyncIo> {
    io: T,
    /*
     * each connection has a client_id generated by ubus
     * in server mode,
     *      this is not used, instead server_obj_id is used
     * in client mode,
     *      this is what server see as a message.header.peer,
     *      but we don't need to set this, (we manually set it to server_obj_id), ubusd will set for us
     */
    // peer: u32,
    /*
     * in client mode,
     *      each request need a sequence to identify from other requests
     *      different client_obj (i.e. new connection) has different client_obj_id so it's okay to use same sequence
     */
    sequence: u16,
    /*
     * not used, we use a heap allocated Vec to store received data
     */
    // buffer: [u8; 64 * 1024],
    server_objs: HashMap<u32, UbusServerObject>,
}

impl<T: AsyncIo> Connection<T> {
    /// Create a new ubus connection from an existing IO
    pub async fn new(io: T) -> Result<Self, UbusError> {
        let mut conn = Self {
            io,
            // peer: 0,
            sequence: 0,
            // buffer: [0u8; 64 * 1024],
            server_objs: HashMap::new(),
        };

        // ubus server should say hello on connect
        let message = conn.next_message().await?;

        // Verify the header is what we expect
        valid_data!(
            message.header.cmd_type == UbusCmdType::HELLO,
            "Expected hello"
        );

        // Record our peer id
        // conn.peer = message.header.peer.into();

        Ok(conn)
    }

    fn header_by_obj_cmd(&mut self, obj_id: u32, cmd: UbusCmdType) -> UbusMsgHeader {
        UbusMsgHeader {
            version: UbusMsgVersion::CURRENT,
            cmd_type: cmd,
            sequence: self.generate_new_request_sequence(),
            peer: obj_id.into(),
        }
    }

    /**
     * sequence is used to identify session, only client need to generate it, server should reply with same sequence with request's
     */
    fn generate_new_request_sequence(&mut self) -> BigEndian<u16> {
        self.sequence += 1;
        BigEndian::<u16>::from(self.sequence)
    }

    // Get next message from ubus channel (blocking!)
    pub async fn next_message(&mut self) -> Result<UbusMsg, UbusError> {
        UbusMsg::from_io(&mut self.io).await
    }

    pub async fn send_message(&mut self, message: UbusMsg) -> Result<(), UbusError> {
        // self.io.put(&Into::<Vec<u8>>::into(message))
        self.io.put(&message.to_bytes()).await
    }

    pub async fn invoke(
        &mut self,
        obj: u32,
        method: &str,
        req_args: MsgTable,
    ) -> Result<MsgTable, UbusError> {
        let request_sequence = self.generate_new_request_sequence();

        // let now = std::time::Instant::now();
        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::INVOKE,
                sequence: request_sequence,
                peer: obj.into(),
            },
            ubus_blobs: vec![
                UbusBlob::ObjId(obj),
                UbusBlob::Method(method.to_string()),
                UbusBlob::Data(req_args),
            ],
        })
        .await?;
        // println!("Elapsed: {:.2?}", now.elapsed());

        let mut reply_args = None;
        /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
        'messages: loop {
            let message = self.next_message().await?;
            if message.header.sequence != request_sequence {
                // FIXME:
                // continue;
            }
            dbg!(&message);

            match message.header.cmd_type {
                UbusCmdType::STATUS => {
                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                if let Some(reply_args) = reply_args {
                                    break 'messages Ok(reply_args);
                                } else {
                                    break 'messages Err(UbusError::InvalidData(
                                        "response is empty",
                                    ));
                                }
                            }
                            UbusBlob::Status(status) => {
                                return Err(UbusError::Status(status));
                            }
                            _ => {}
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid status message"));
                }
                UbusCmdType::DATA => {
                    for blob in message.ubus_blobs {
                        // dbg!(&blob);
                        if let UbusBlob::Data(data) = blob {
                            reply_args = Some(data);
                            // dbg!(&reply_args);
                            continue 'messages;
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid data message"));
                }
                unknown => {
                    dbg!(unknown);
                }
            }
        }
    }

    pub async fn call<'a>(
        &'a mut self,
        obj_path: &'a str,
        method: &'a str,
        req_args: &'a str,
    ) -> Result<String, UbusError> {
        // let obj_json = self.lookup_object_json(obj_path)?;
        // // dbg!(&obj_json);
        // let obj: UbusObject = serde_json::from_str(&obj_json)?;
        // dbg!(&obj);
        // let req_args = obj.args_from_json(method, args).expect("not valid json");
        let obj_id = self.lookup_id(obj_path).await?;
        let req_args = MsgTable::try_from(req_args)?;
        // dbg!(&args, &req_args);
        let reply_args = self.invoke(obj_id, method, req_args).await?;

        Ok(dbg!(reply_args.try_into()?))

        // dbg!(&bi);

        // let json = {
        //     let mut json = String::new();
        //     json += "{\n";
        //     let mut first = true;
        //     for msg in reply_args.0 {
        //         // dbg!(&msg);
        //         if !first {
        //             json += ",\n";
        //         }
        //         //json_str += &format!("{:?}", x);
        //         json += &format!("\t{}", msg);
        //         first = false;
        //     }
        //     json += "\n}";
        //     json
        // };
        // Ok(json)
    }

    // pub fn lookup_object_json<'a>(&'a mut self, obj_path: &'a str) -> Result<String, UbusError> {
    //     serde_json::to_string_pretty(&self.lookup(obj_path)?.get(0))
    //         .map_err(|e| UbusError::InvalidData("Failed to stringify"))
    // }

    pub async fn lookup_id(&mut self, obj_path: &str) -> Result<u32, UbusError> {
        Ok(self
            .lookup(obj_path)
            .await?
            .get(0)
            .ok_or(UbusError::InvalidPath(obj_path.to_string()))?
            .id)
    }

    pub async fn lookup(&mut self, obj_path: &str) -> Result<Vec<UbusObject>, UbusError> {
        let request_sequence = self.generate_new_request_sequence();

        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::LOOKUP,
                sequence: request_sequence,
                peer: 0.into(),
            },
            ubus_blobs: obj_path
                .is_empty()
                .not()
                .then(|| UbusBlob::ObjPath(obj_path.to_string()))
                .into_iter()
                .collect(),
        })
        .await?;

        let objs = {
            let mut objs = Vec::new();
            /* TODO: optimize logic, too much mut, too much duplicate! */
            'message_iter: loop {
                let message = self.next_message().await?;
                dbg!(&message);
                // println!("{:#?}", &message);
                if message.header.sequence != request_sequence {
                    continue;
                }

                /* here the `obj` is inserted with some reference from `message`, then if we try to return it, rust ensure `message` should live longer than `obj`   */
                /* i check the code, message is a lot of slice to a global buffer in Connection, each time next_message() got called, the global buffer got overriden */
                let mut obj = UbusObject::default();

                match message.header.cmd_type {
                    UbusCmdType::STATUS => {
                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::Status(UbusMsgStatus::OK) => {
                                    break 'message_iter Ok(objs);
                                }
                                UbusBlob::Status(status) => {
                                    break 'message_iter Err(UbusError::Status(status));
                                }
                                _ => {}
                            }
                        }
                        return Err(UbusError::InvalidData("Invalid status message"));
                    }
                    UbusCmdType::DATA => {
                        for blob in message.ubus_blobs {
                            match blob {
                                UbusBlob::ObjPath(path) => obj.path = path.to_string(),
                                UbusBlob::ObjId(id) => obj.id = id as u32,
                                UbusBlob::ObjType(ty) => obj.objtype = ty as u32,
                                UbusBlob::Signature(nested) => {
                                    obj.reported_signature = nested;
                                }
                                _ => {}
                            }
                        }
                        objs.push(obj);
                    }
                    _ => {}
                }
            }
        };
        objs
    }

    /*
     * send:        add_object: {"objpath":"test","signature":{"hello":{"id":5,"msg":3},"watch":{"id":5,"counter":5},"count":{"to":5,"string":3}}}
     * return:      data:       {"objid":2013531835,"objtype":-1292016789}
     */


    /**
    Regsister a server object with obj_path, method_name and method_callbacks
      use a `UbusServerObjectBuilder` to build them

      the callback is wrapped in Box to support closure capture

    TODO: currently a `listening()` call is need to listen future requests, maybe I should find a better way


      ### Example
      ```
      let _ = connection
        .add_server(UbusServerObjectBuilder::new("t2").method(
            "hi",
            Box::new(|req_args: &MsgTable| MsgTable::try_from(r#"{ "clo": "sure" }"#).unwrap()),
        ))
        .await
        .unwrap();
      ```
    */
    pub async fn add_server(
        &mut self,
        server_obj_builder: UbusServerObjectBuilder,
    ) -> Result<&UbusServerObject, UbusError> {
        let mut new_server_obj: UbusServerObject = UbusServerObject::default();
        // server_obj.methods = methods;

        // FIXME\: official ubus cli call stuck while data in monitor looks good <- fixed: replied seq should be same as requested
        {
            let request_sequence = self.generate_new_request_sequence();
            self.send_message(UbusMsg {
                header: UbusMsgHeader {
                    version: UbusMsgVersion::CURRENT,
                    cmd_type: UbusCmdType::ADD_OBJECT,
                    sequence: request_sequence,
                    peer: 0.into(),
                },
                ubus_blobs: vec![
                    UbusBlob::ObjPath(server_obj_builder.path),
                    UbusBlob::Signature(
                        server_obj_builder
                            .methods
                            .iter()
                            .map(|(method, _)| BlobMsg {
                                name: method.to_string(),
                                data: BlobMsgPayload::Table(Vec::new()),
                            })
                            .collect::<Vec<BlobMsg>>()
                            .into(),
                    ),
                ],
            })
            .await?;

            /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
            let reply_args = 'message_loop: loop {
                let message = self.next_message().await?;
                if message.header.sequence != request_sequence {
                    continue;
                }
                dbg!(&message);

                match message.header.cmd_type {
                    UbusCmdType::STATUS => {
                        for blob in message.ubus_blobs {
                            match blob {
                                UbusBlob::Status(UbusMsgStatus::OK) => {
                                    break 'message_loop Ok(());
                                }
                                UbusBlob::Status(status) => {
                                    break 'message_loop Err(UbusError::Status(status));
                                }
                                _ => {}
                            }
                        }
                        break 'message_loop Err(UbusError::InvalidData("Invalid status message"));
                    }
                    UbusCmdType::DATA => {
                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::ObjId(id) => new_server_obj.id = id,
                                UbusBlob::ObjType(objtype) => new_server_obj.objtype = objtype,
                                _ => todo!(),
                            }
                        }
                    }
                    unknown => {
                        dbg!(unknown);
                    }
                }
            };
        };

        new_server_obj.methods = server_obj_builder.methods;
        let new_server_obj_id = new_server_obj.id;
        self.server_objs.insert(new_server_obj_id, new_server_obj);
        Ok(&self.server_objs.get(&new_server_obj_id).unwrap())
    }

    /*
     * server:
     * receive: invoke: {"objid":2013531835,"method":"hello","data":{"msg":"fsdfsdf"},"user":"fifv","group":"fifv"}
     * reply:   data:   {"objid":2013531835,"data":{"message":"test received a message: fsdfsdf"}}
     * reply:   status: {"status":0,"objid":2013531835}
     *
     * FIXME: the read loop conflict with client read response after invoke
     *
     */
    pub async fn listening(&mut self) -> Result<(), UbusError> {
        /* FIXME: it may be not ideal to abuse ? to throw error, each error should be handled correctly */
        // let server_objs_map = HashMap::<u32, UbusServerObject>::from_iter(
        //     server_objs.into_iter().map(|obj| (obj.id, obj)),
        // );
        /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
        'message_loop: loop {
            let message = self.next_message().await?;
            // if message.header.sequence != header.sequence {
            //     continue;
            // }
            dbg!(&message);

            match message.header.cmd_type {
                /*
                 * server object normally won't got a status, instead, server will send back a status OK to terminate client
                 */
                UbusCmdType::STATUS => {
                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                // break 'messages Ok(());
                            }
                            UbusBlob::Status(status) => {
                                return Err(UbusError::Status(status));
                            }
                            _ => {}
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid status message"));
                }
                UbusCmdType::INVOKE => {
                    /*
                     * client's INVOKE contains:
                     *      - `message.header.peer`         : the client's obj_id, should be used as `message.header.peer` when reply
                     *      - `message.header.sequence`     : used to identify current session, should be used as `message.header.sequence` when reply
                     *      - `message.ubus_blobs.?.ObjId`  : current server obj_id, should be used as `message.ubus_blobs.?.ObjId` when reply.
                     *                                        this is same as the response from add_server
                     *      - `message.ubus_blobs.?.Method` : client want to call this method
                     *      - `message.ubus_blobs.?.Data`   : client requested with this json
                     */
                    // TODO: use Option
                    if let Some((requested_server_obj_id, method_name, req_args)) = {
                        let mut requested_server_obj_id = None;
                        let mut method_name = None;
                        let mut req_args = None;
                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::ObjId(id) => requested_server_obj_id = Some(id),
                                UbusBlob::Method(method) => method_name = Some(method),
                                UbusBlob::Data(msg_table) => req_args = Some(msg_table),
                                _ => {}
                            }
                        }
                        match (requested_server_obj_id, method_name, req_args) {
                            (Some(requested_server_obj_id), Some(method_name), Some(req_args)) => {
                                Some((requested_server_obj_id, method_name, req_args))
                            }
                            _ => None,
                        }
                    } {
                        // tokio::runtime::Runtime::new().unwrap().block_on(async {});

                        /* reply to client */

                        if let Some(server_obj) = self.server_objs.get(&requested_server_obj_id) {
                            match server_obj.methods.get(&method_name) {
                                Some(method) => {
                                    tokio::spawn(async {});
                                    let reply_args = method(&req_args);
                                    /* here client_obj_id == server objid */
                                    self.send_message(UbusMsg{
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::DATA,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Data(reply_args),/* data is moved to enum, then moved to UbusMsg */
                                        ],
                                    }).await?;

                                    // dbg!(reply_args);

                                    // sleep(Duration::from_millis(400));

                                    self.send_message(UbusMsg {
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::STATUS,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Status(UbusMsgStatus::OK),
                                        ],
                                    })
                                    .await?;
                                }
                                None => {
                                    /* method not found */
                                    self.send_message(UbusMsg {
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::STATUS,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Status(UbusMsgStatus::METHOD_NOT_FOUND),
                                        ],
                                    })
                                    .await?;
                                }
                            }
                        } else {
                            /* server obj not found */
                            self.send_message(UbusMsg {
                                header: UbusMsgHeader {
                                    version: UbusMsgVersion::CURRENT,
                                    cmd_type: UbusCmdType::STATUS,
                                    sequence: message.header.sequence,
                                    peer: message.header.peer,
                                },
                                ubus_blobs: vec![
                                    UbusBlob::ObjId(requested_server_obj_id),
                                    UbusBlob::Status(UbusMsgStatus::NOT_FOUND),
                                ],
                            })
                            .await?;
                        }
                    };
                }

                unknown => {
                    dbg!(unknown);
                }
            }
        }
    }

    /* UNIMPLEMENTED */
    pub async fn notify(&mut self, server_obj: &UbusServerObject) {
        let new_request_sequence = self.generate_new_request_sequence();
        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::NOTIFY,
                sequence: new_request_sequence,
                peer: server_obj.id.into(),
            },
            ubus_blobs: vec![
                UbusBlob::ObjId(server_obj.id),
                UbusBlob::Status(UbusMsgStatus::OK),
            ],
        })
        .await.expect("???");
    }
}
