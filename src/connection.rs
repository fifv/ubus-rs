use crate::*;

use core::{f32::consts::E, ops::Not};
use std::{
    boxed::Box,
    collections::HashMap,
    dbg, format, println,
    string::ToString,
    sync::{Arc, Mutex},
    vec::Vec,
};
extern crate alloc;
use alloc::string::String;
use serde_json::json;
use std::vec;
use storage_endian::BigEndian;
use tokio::{sync::mpsc, task::JoinSet};
use ubuserror::*;

#[derive(Copy, Clone)]
pub struct ObjectResult<'a> {
    pub path: &'a str,
    pub id: u32,
    pub ty: u32,
}
impl core::fmt::Debug for ObjectResult<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(f, "{} @0x{:08x} type={:08x}", self.path, self.id, self.ty)
    }
}

pub struct SignatureResult<'a> {
    pub object: ObjectResult<'a>,
    pub name: String,
    pub args: HashMap<String, BlobMsgType>,
}

#[derive()]
pub struct Connection {
    // io: T,
    /*
     * each connection has a client_id generated by ubus
     * in server mode,
     *      this is not used, instead server_obj_id is used
     * in client mode,
     *      this is what server see as a message.header.peer,
     *      but we don't need to set this, (we manually set it to server_obj_id), ubusd will set for us
     */
    // peer: u32,
    /*
     * in client mode,
     *      each request need a sequence to identify from other requests
     *      different client_obj (i.e. new connection) has different client_obj_id so it's okay to use same sequence
     */
    sequence: u16,
    /*
     * not used, we use a heap allocated Vec to store received data
     */
    // buffer: [u8; 64 * 1024],
    /**
     * server_obj_id to UbusServerObject, mainly used to store the callbacks
     */
    server_objs: Arc<Mutex<HashMap<u32, UbusServerObject>>>,
    /**
     * (need redesign) if a UbusMsg is received from socket, the MassageManager will use the (peer, objid, seq) to identify which received to send
     * seq
     */
    reply_receivers_tx: Arc<Mutex<HashMap<u16, mpsc::Sender<UbusMsg>>>>,
    /**
     * should each server has its own channel?
     */
    invoke_receiver_tx: mpsc::Sender<UbusMsg>,
    // invoke_receiver_rx: mpsc::Receiver<UbusMsg>,
    /**
     * send message to MessageManager and let it send to wire
     */
    message_sender_tx: mpsc::Sender<UbusMsg>,
    /**
     * run necessary loops in background, spawned in new(), aborted when dropped
     *  - invoke_handler    :   handle client's INVOKEs and call callbacks
     *  - message_manager   :   communicate with io (e.g. ubusd via UnixStream), dispatch messages through channels
     */
    communication_loops: JoinSet<Result<(), UbusError>>,
}

impl Connection {
    /**
     * Create a new ubus connection from an existing IO
     *
     */
    pub async fn new<R: AsyncIoReader, W: AsyncIoWriter>(
        (io_reader, io_writer): (R, W),
    ) -> Result<Self, UbusError> {
        let (invoke_receiver_tx, invoke_receiver_rx) = mpsc::channel(1);
        let (message_sender_tx, message_sender_rx) = mpsc::channel(1);

        let mut conn = Self {
            // peer: 0,
            sequence: 0,
            // buffer: [0u8; 64 * 1024],
            server_objs: Arc::new(Mutex::new(HashMap::new())),
            reply_receivers_tx: Arc::new(Mutex::new(HashMap::new())),
            invoke_receiver_tx: invoke_receiver_tx.clone(),
            message_sender_tx: message_sender_tx.clone(),
            // invoke_handler: None,
            // message_manager: None,
            communication_loops: JoinSet::new(),
        };

        let reply_receivers_tx = conn.reply_receivers_tx.clone();
        let invoke_receiver_tx1 = invoke_receiver_tx;
        /*
         * spawn and move the io to it makes it run forever, independent of how long the Connection struct lives
         */
        /* message manager */
        /* move io here */

        // conn.invoke_handler = Some(Box::new(invoke_handler));
        // conn.message_manager = Some(Box::new(message_manager));
        conn.communication_loops.spawn(Self::run_invoke_handler(
            conn.server_objs.clone(),
            invoke_receiver_rx,
            message_sender_tx,
        ));
        conn.communication_loops
            .spawn(Self::run_message_manager_receiver(
                io_reader,
                reply_receivers_tx,
                invoke_receiver_tx1,
            ));
        conn.communication_loops
            .spawn(Self::run_message_manager_sender(
                io_writer,
                message_sender_rx,
            ));

        // ubus server should say hello on connect
        // let message = conn.next_message().await?;

        // // Verify the header is what we expect
        // valid_data!(
        //     message.header.cmd_type == UbusCmdType::HELLO,
        //     "Expected hello"
        // );

        // Record our peer id
        // conn.peer = message.header.peer.into();

        Ok(conn)
    }

    /**
     * block forever.
     * this doesn't need to be call to run, loops are running in background when `new()`
     */
    pub async fn run(self) {
        // futures::future::join_all([self.invoke_handler.unwrap()])
        // let mut set = JoinSet::new();
        // set.spawn((self.invoke_handler.unwrap()))
        self.communication_loops.join_all().await;
    }

    // fn header_by_obj_cmd(&mut self, obj_id: u32, cmd: UbusCmdType) -> UbusMsgHeader {
    //     UbusMsgHeader {
    //         version: UbusMsgVersion::CURRENT,
    //         cmd_type: cmd,
    //         sequence: self.generate_new_request_sequence(),
    //         peer: obj_id.into(),
    //     }
    // }

    // Get next message from ubus channel (blocking!)
    // pub async fn next_message(&mut self) -> Result<UbusMsg, UbusError> {
    //     // UbusMsg::from_io(&mut self.io).await
    //     // self.
    // }
    pub async fn send_message(&self, message: UbusMsg) -> Result<(), UbusError> {
        // self.io.put(&Into::<Vec<u8>>::into(message))
        // self.io.put(&message.to_bytes()).await
        self.message_sender_tx
            .send(message)
            .await
            .map_err(|_| UbusError::UnexpectChannelClosed())
    }

    pub async fn invoke(
        &mut self,
        server_obj_id: HexU32,
        method: &str,
        req_args: MsgTable,
    ) -> Result<MsgTable, UbusError> {
        let new_request_sequence = self.generate_new_request_sequence();

        let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
        self.reply_receivers_tx
            .lock()
            .unwrap()
            .insert(new_request_sequence.into(), reply_receiver_tx);

        // let now = std::time::Instant::now();
        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::INVOKE,
                sequence: new_request_sequence,
                peer: u32::from(server_obj_id).into(),
            },
            ubus_blobs: vec![
                UbusBlob::ObjId(server_obj_id),
                UbusBlob::Method(method.to_string()),
                UbusBlob::Data(req_args),
            ],
        })
        .await?;
        // println!("Elapsed: {:.2?}", now.elapsed());

        let mut reply_args = None;
        /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
        'messages: loop {
            // let message = self.next_message().await?;
            let message = reply_receiver_rx.recv().await.unwrap();
            if message.header.sequence != new_request_sequence {
                // FIXME:
                // continue;
            }
            // dbg!(&message);

            match message.header.cmd_type {
                UbusCmdType::STATUS => {
                    /*
                     * remove the channel to save memory, e.g. channel(8) x 65535 consume ~100MB
                     */
                    self.reply_receivers_tx
                        .lock()
                        .unwrap()
                        .remove(&new_request_sequence.into());

                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                if let Some(reply_args) = reply_args {
                                    break 'messages Ok(reply_args);
                                } else {
                                    break 'messages Err(UbusError::InvalidData(
                                        "response is empty",
                                    ));
                                }
                            }
                            UbusBlob::Status(status) => {
                                return Err(UbusError::Status(status));
                            }
                            _ => {}
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid status message"));
                }
                UbusCmdType::DATA => {
                    for blob in message.ubus_blobs {
                        // dbg!(&blob);
                        if let UbusBlob::Data(data) = blob {
                            reply_args = Some(data);
                            // dbg!(&reply_args);
                            continue 'messages;
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid data message"));
                }
                unknown => {
                    dbg!(unknown);
                }
            }
        }
    }

    pub async fn call<'a>(
        &'a mut self,
        obj_path: &'a str,
        method: &'a str,
        req_args: &'a str,
    ) -> Result<String, UbusError> {
        // let obj_json = self.lookup_object_json(obj_path)?;
        // // dbg!(&obj_json);
        // let obj: UbusObject = serde_json::from_str(&obj_json)?;
        // dbg!(&obj);
        // let req_args = obj.args_from_json(method, args).expect("not valid json");
        let obj_id = self.lookup_id(obj_path).await?;
        let req_args = MsgTable::try_from(req_args)?;
        // dbg!(&args, &req_args);
        let reply_args = self.invoke(obj_id, method, req_args).await?;

        Ok(dbg!(reply_args.try_into()?))

        // dbg!(&bi);

        // let json = {
        //     let mut json = String::new();
        //     json += "{\n";
        //     let mut first = true;
        //     for msg in reply_args.0 {
        //         // dbg!(&msg);
        //         if !first {
        //             json += ",\n";
        //         }
        //         //json_str += &format!("{:?}", x);
        //         json += &format!("\t{}", msg);
        //         first = false;
        //     }
        //     json += "\n}";
        //     json
        // };
        // Ok(json)
    }

    // pub fn lookup_object_json<'a>(&'a mut self, obj_path: &'a str) -> Result<String, UbusError> {
    //     serde_json::to_string_pretty(&self.lookup(obj_path)?.get(0))
    //         .map_err(|e| UbusError::InvalidData("Failed to stringify"))
    // }

    pub async fn lookup_id(&mut self, obj_path: &str) -> Result<HexU32, UbusError> {
        Ok(self
            .lookup(obj_path)
            .await?
            .get(0)
            .ok_or(UbusError::InvalidPath(obj_path.to_string()))?
            .id
            .into())
    }

    pub async fn lookup(&mut self, obj_path: &str) -> Result<Vec<UbusObject>, UbusError> {
        let new_request_sequence = self.generate_new_request_sequence();

        let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
        self.reply_receivers_tx
            .lock()
            .unwrap()
            .insert(new_request_sequence.into(), reply_receiver_tx);

        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::LOOKUP,
                sequence: new_request_sequence,
                peer: 0.into(),
            },
            ubus_blobs: obj_path
                .is_empty()
                .not()
                .then(|| UbusBlob::ObjPath(obj_path.to_string()))
                .into_iter()
                .collect(),
        })
        .await?;

        let objs = {
            let mut objs = Vec::new();
            /* TODO: optimize logic, too much mut, too much duplicate! */
            'message_iter: loop {
                // let message = self.next_message().await?;
                let message = reply_receiver_rx.recv().await.unwrap();

                // dbg!(&message);
                // println!("{:#?}", &message);
                if message.header.sequence != new_request_sequence {
                    continue;
                }

                /* here the `obj` is inserted with some reference from `message`, then if we try to return it, rust ensure `message` should live longer than `obj`   */
                /* i check the code, message is a lot of slice to a global buffer in Connection, each time next_message() got called, the global buffer got overriden */
                let mut obj = UbusObject::default();

                match message.header.cmd_type {
                    UbusCmdType::STATUS => {
                        self.reply_receivers_tx
                            .lock()
                            .unwrap()
                            .remove(&new_request_sequence.into());

                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::Status(UbusMsgStatus::OK) => {
                                    break 'message_iter Ok(objs);
                                }
                                UbusBlob::Status(status) => {
                                    break 'message_iter Err(UbusError::Status(status));
                                }
                                _ => {}
                            }
                        }
                        return Err(UbusError::InvalidData("Invalid status message"));
                    }
                    UbusCmdType::DATA => {
                        for blob in message.ubus_blobs {
                            match blob {
                                UbusBlob::ObjPath(path) => obj.path = path.to_string(),
                                UbusBlob::ObjId(id) => obj.id = id,
                                UbusBlob::ObjType(ty) => obj.objtype = ty,
                                UbusBlob::Signature(nested) => {
                                    obj.reported_signature = nested;
                                }
                                _ => {}
                            }
                        }
                        objs.push(obj);
                    }
                    _ => {}
                }
            }
        };
        objs
    }

    /*
     * ### When add_object
     * send:        add_object: {"objpath":"test","signature":{"hello":{"id":5,"msg":3},"watch":{"id":5,"counter":5},"count":{"to":5,"string":3}}}
     * return:      data:       {"objid":2013531835,"objtype":-1292016789}
     */

    /*
     * ### When handle INVOKE
     * server:
     * receive: invoke: {"objid":2013531835,"method":"hello","data":{"msg":"fsdfsdf"},"user":"fifv","group":"fifv"}
     * reply:   data:   {"objid":2013531835,"data":{"message":"test received a message: fsdfsdf"}}
     * reply:   status: {"status":0,"objid":2013531835}
     *
     * FIXME: the read loop conflict with client read response after invoke
     *
     */

    /**
    Regsister a server object with obj_path, method_name and method_callbacks
      use a `UbusServerObjectBuilder` to build them

      the callback is wrapped in Box to support closure capture

    TODO: currently a `listening()` call is need to listen future requests, maybe I should find a better way


      ### Example
      ```
      let _ = connection
        .add_server(UbusServerObjectBuilder::new("t2").method(
            "hi",
            Box::new(|req_args: &MsgTable| MsgTable::try_from(r#"{ "clo": "sure" }"#).unwrap()),
        ))
        .await
        .unwrap();
      ```
    */
    pub async fn add_server(
        &mut self,
        server_obj_builder: UbusServerObjectBuilder,
    ) -> Result<u32, UbusError> {
        let mut new_server_obj: UbusServerObject = UbusServerObject::default();
        // server_obj.methods = methods;

        // FIXME\: official ubus cli call stuck while data in monitor looks good <- fixed: replied seq should be same as requested
        {
            let new_request_sequence = self.generate_new_request_sequence();

            let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
            self.reply_receivers_tx
                .lock()
                .unwrap()
                .insert(new_request_sequence.into(), reply_receiver_tx);

            self.send_message(UbusMsg {
                header: UbusMsgHeader {
                    version: UbusMsgVersion::CURRENT,
                    cmd_type: UbusCmdType::ADD_OBJECT,
                    sequence: new_request_sequence,
                    peer: 0.into(),
                },
                ubus_blobs: vec![
                    UbusBlob::ObjPath(server_obj_builder.path),
                    UbusBlob::Signature(
                        server_obj_builder
                            .methods
                            .iter()
                            .map(|(method, _)| BlobMsg {
                                name: method.to_string(),
                                data: BlobMsgPayload::Table(Vec::new()),
                            })
                            .collect::<Vec<BlobMsg>>()
                            .into(),
                    ),
                ],
            })
            .await?;

            /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
            let _reply_args = 'message_loop: loop {
                let message = reply_receiver_rx.recv().await.unwrap();
                if message.header.sequence != new_request_sequence {
                    continue;
                }
                // dbg!(&message);

                match message.header.cmd_type {
                    UbusCmdType::STATUS => {
                        self.reply_receivers_tx
                            .lock()
                            .unwrap()
                            .remove(&new_request_sequence.into());

                        for blob in message.ubus_blobs {
                            match blob {
                                UbusBlob::Status(UbusMsgStatus::OK) => {
                                    break 'message_loop Ok(());
                                }
                                UbusBlob::Status(status) => {
                                    break 'message_loop Err(UbusError::Status(status));
                                }
                                _ => {}
                            }
                        }
                        break 'message_loop Err(UbusError::InvalidData("Invalid status message"));
                    }
                    UbusCmdType::DATA => {
                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::ObjId(id) => new_server_obj.id = id,
                                UbusBlob::ObjType(objtype) => new_server_obj.objtype = objtype,
                                _ => todo!(),
                            }
                        }
                    }
                    unknown => {
                        dbg!(unknown);
                    }
                }
            };
        };

        new_server_obj.methods = server_obj_builder.methods;
        let new_server_obj_id = new_server_obj.id;
        self.server_objs
            .lock()
            .unwrap()
            .insert(new_server_obj_id.into(), new_server_obj);
        Ok(new_server_obj_id.into())
    }

    /*
     *  ### When client subscribe
     * client send:     subscribe:  {"objid":1711030590}
     * server receive:  notify:     {"objid":130751756,"active":true}
     * client receive:  status:     {"status":0}
     *
     *  ### When client unsubscribe
     * server receive:  notify:     {"objid":130751756,"active":false}
     *
     *  ### When server notify
     */
    pub async fn notify(
        &mut self,
        server_obj_id: u32,
        method: &str,
        data: MsgTable,
    ) -> Result<(), UbusError> {
        let new_request_sequence = self.generate_new_request_sequence();

        let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
        self.reply_receivers_tx
            .lock()
            .unwrap()
            .insert(new_request_sequence.into(), reply_receiver_tx);

        // println!("1");
        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::NOTIFY,
                sequence: new_request_sequence,
                peer: server_obj_id.into(),
            },
            ubus_blobs: vec![
                UbusBlob::ObjId(server_obj_id.into()),
                UbusBlob::Method(method.into()),
                UbusBlob::Data(data),
            ],
        })
        .await?;
        // println!("2");

        /*
         *  ISSUE: the reply of notify is useless, but unlimited
         * it causes race and stuck sometimes... why?
         * â†‘ because I register callback after send_message(), so if reply is instant, the message manager get a message before
         * I register the receiver, and it doesn't find a receiver, just drop the message
         */


        // println!("3");

        /*
         * when server send a notify, it will receive:
         *      1.   Status::OK - send to ubus successfully
         *      2..  Status::OK - each successfully received client send one, infinitly
         */
        'messages: loop {
            // let message = self.next_message().await?;
            let message = reply_receiver_rx.recv().await.unwrap();

            // dbg!(&message);
            // println!("4");

            /*
             * client may report  Status(METHOD_NOT_FOUND) , but thats not we care about, only use as a debug
             */
            match message.header.cmd_type {
                UbusCmdType::STATUS => {
                    self.reply_receivers_tx
                        .lock()
                        .unwrap()
                        .remove(&new_request_sequence.into());

                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                break 'messages;
                            }
                            UbusBlob::Status(status) => {
                                // return Err(UbusError::Status(status));
                                log::trace!(
                                    "subscriber {:08x} report error: {}",
                                    message.header.peer,
                                    status
                                )
                            }
                            /* only reach here if no subscribers exist, with an empty MsgTable */
                            UbusBlob::Subscribers(subscribers) => {
                                // println!("subscribers: {:?}", subscribers);
                            }
                            _ => {}
                        }
                    }
                    /* maybe no need to know how much client respond a Status::OK, it's not easy to track all */
                    break 'messages;
                    // return Err(UbusError::InvalidData("Invalid status message"));
                }
                unknown => {
                    dbg!(unknown);
                }
            }
        }
        Ok(())
    }

    pub async fn subscribe(
        &mut self,
        listener_obj_id: HexU32,
        server_obj_id: HexU32,
    ) -> Result<(), UbusError> {
        let new_request_sequence = self.generate_new_request_sequence();

        let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
        self.reply_receivers_tx
            .lock()
            .unwrap()
            .insert(new_request_sequence.into(), reply_receiver_tx);

        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: UbusCmdType::SUBSCRIBE,
                sequence: new_request_sequence,
                peer: 0.into(),
            },
            ubus_blobs: vec![
                UbusBlob::ObjId(listener_obj_id),
                UbusBlob::Target(server_obj_id),
            ],
        })
        .await?;


        /*
         * when server send a notify, it will receive:
         *      1.   Status::OK - send to ubus successfully
         *      2..  Status::OK - each successfully received client send one, infinitly
         */
        'messages: loop {
            // let message = self.next_message().await?;
            let message = reply_receiver_rx.recv().await.unwrap();
            if message.header.sequence != new_request_sequence {
                // FIXME:
                // continue;
            }
            // dbg!(&message);

            match message.header.cmd_type {
                UbusCmdType::STATUS => {
                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                break 'messages;
                            }
                            UbusBlob::Status(status) => {
                                return Err(UbusError::Status(status));
                            }
                            UbusBlob::Subscribers(subscribers) => {
                                // println!("subscribers: {:?}", subscribers);
                            }
                            _ => {}
                        }
                    }
                    /* maybe no need to know how much client respond a Status::OK, it's not easy to track all */
                    break 'messages;
                    // return Err(UbusError::InvalidData("Invalid status message"));
                }
                unknown => {
                    dbg!(unknown);
                }
            }
        }
        Ok(())
    }
}

/**
 * internally used
 */
impl Connection {
    /**
     * sequence is used to identify session, only client need to generate it, server should reply with same sequence with request's
     */
    fn generate_new_request_sequence(&mut self) -> BigEndian<u16> {
        self.sequence = self.sequence.wrapping_add(1);
        BigEndian::<u16>::from(self.sequence)
        /* also seems okay to use random number */
        // BigEndian::<u16>::from(random::<u16>(..))
    }

    async fn run_invoke_handler(
        server_objs: Arc<Mutex<HashMap<u32, UbusServerObject>>>,
        mut invoke_receiver_rx: mpsc::Receiver<UbusMsg>,
        message_sender_tx: mpsc::Sender<UbusMsg>,
    ) -> Result<(), UbusError> {
        /* FIXME: it may be not ideal to abuse ? to throw error, each error should be handled correctly */
        // let server_objs_map = HashMap::<u32, UbusServerObject>::from_iter(
        //     server_objs.into_iter().map(|obj| (obj.id, obj)),
        // );
        /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */

        loop {
            let message = invoke_receiver_rx
                .recv()
                .await
                .ok_or(UbusError::UnexpectChannelClosed())?;
            // if message.header.sequence != header.sequence {
            //     continue;
            // }
            // dbg!(&message);

            match message.header.cmd_type {
                /*
                 * server object normally won't got a status, instead, server will send back a status OK to terminate client
                 */
                UbusCmdType::STATUS => {
                    for blob in message.ubus_blobs {
                        match blob {
                            UbusBlob::Status(UbusMsgStatus::OK) => {
                                // break 'messages Ok(());
                            }
                            UbusBlob::Status(status) => {
                                return Err(UbusError::Status(status));
                            }
                            _ => {}
                        }
                    }
                    return Err(UbusError::InvalidData("Invalid status message"));
                }
                UbusCmdType::INVOKE => {
                    /*
                     * client's INVOKE contains:
                     *      - `message.header.peer`         : the client's obj_id, should be used as `message.header.peer` when reply
                     *      - `message.header.sequence`     : used to identify current session, should be used as `message.header.sequence` when reply
                     *      - `message.ubus_blobs.?.ObjId`  : current server obj_id, should be used as `message.ubus_blobs.?.ObjId` when reply.
                     *                                        this is same as the response from add_server
                     *      - `message.ubus_blobs.?.Method` : client want to call this method
                     *      - `message.ubus_blobs.?.Data`   : client requested with this json
                     */
                    // TODO: use Option
                    if let Some((requested_server_obj_id, method_name, req_args)) = {
                        let mut requested_server_obj_id = None;
                        let mut method_name = None;
                        let mut req_args = None;
                        for blob in message.ubus_blobs {
                            // dbg!(&blob);
                            match blob {
                                UbusBlob::ObjId(id) => requested_server_obj_id = Some(id),
                                UbusBlob::Method(method) => method_name = Some(method),
                                UbusBlob::Data(msg_table) => req_args = Some(msg_table),
                                _ => {}
                            }
                        }
                        match (requested_server_obj_id, method_name, req_args) {
                            (Some(requested_server_obj_id), Some(method_name), Some(req_args)) => {
                                Some((requested_server_obj_id, method_name, req_args))
                            }
                            _ => None,
                        }
                    } {
                        enum FindMethodStatus {
                            Found(UbusMethod),
                            ObjectNotFound,
                            MethodNotFound,
                        }
                        // tokio::runtime::Runtime::new().unwrap().block_on(async {});

                        /* reply to client */

                        /*
                         * try to get the method from the HashMap, clone the method Arc, then drop the sync::Mutex
                         * if we doesn't drop the Mutex,
                         *      1. it can't be Send, compiler errors
                         *      2. if the callback takes time, the callbacks HashMap is locked, and other callbacks can't get called
                         */
                        let find_method_result = if let Some(server_obj) = server_objs
                            .lock()
                            .unwrap()
                            .get(&requested_server_obj_id.into())
                        {
                            match server_obj.methods.get(&method_name) {
                                Some(method) => FindMethodStatus::Found(method.clone()),
                                None => FindMethodStatus::MethodNotFound,
                            }
                        } else {
                            FindMethodStatus::ObjectNotFound
                        };

                        match find_method_result {
                            FindMethodStatus::Found(method) => {
                                // tokio::spawn(async {});
                                let reply_args = method(&req_args);
                                /* here client_obj_id == server objid */
                                message_sender_tx.send(UbusMsg{
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::DATA,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Data(reply_args),/* data is moved to enum, then moved to UbusMsg */
                                        ],
                                    }).await.unwrap();

                                // dbg!(reply_args);

                                // sleep(Duration::from_millis(400));

                                message_sender_tx
                                    .send(UbusMsg {
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::STATUS,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Status(UbusMsgStatus::OK),
                                        ],
                                    })
                                    .await
                                    .unwrap();
                            }
                            FindMethodStatus::MethodNotFound => {
                                /* method not found */
                                message_sender_tx
                                    .send(UbusMsg {
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::STATUS,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Status(UbusMsgStatus::METHOD_NOT_FOUND),
                                        ],
                                    })
                                    .await
                                    .unwrap();
                            }
                            FindMethodStatus::ObjectNotFound => {
                                /* server obj not found */
                                message_sender_tx
                                    .send(UbusMsg {
                                        header: UbusMsgHeader {
                                            version: UbusMsgVersion::CURRENT,
                                            cmd_type: UbusCmdType::STATUS,
                                            sequence: message.header.sequence,
                                            peer: message.header.peer,
                                        },
                                        ubus_blobs: vec![
                                            UbusBlob::ObjId(requested_server_obj_id),
                                            UbusBlob::Status(UbusMsgStatus::NOT_FOUND),
                                        ],
                                    })
                                    .await
                                    .unwrap();
                            }
                        }
                    };
                }

                unknown => {
                    dbg!(unknown);
                }
            }
        }
    }

    /**
     * message_manager, previously i combine them with tokio::select(), but i don' know is it safe,
     * as the select docs says read_exact and write_all are not cancellation safe and can lead to loss of data
     */
    fn run_message_manager_receiver<R: AsyncIoReader>(
        mut io_reader: R,
        reply_receivers_tx: Arc<Mutex<HashMap<u16, mpsc::Sender<UbusMsg>>>>,
        invoke_receiver_tx1: mpsc::Sender<UbusMsg>,
    ) -> impl Future<Output = Result<(), UbusError>> {
        let message_manager_receiver = async move {
            loop {
                if let Ok(message) = UbusMsg::from_io(&mut io_reader).await {
                    // dbg!(&message);
                    log::trace!("got message: {:?}", &message);
                    match message {
                        UbusMsg {
                            header:
                                UbusMsgHeader {
                                    cmd_type: UbusCmdType::INVOKE,
                                    version: _,
                                    sequence: _,
                                    peer: _,
                                },
                            ubus_blobs: _,
                        } => {
                            invoke_receiver_tx1
                                .send(message)
                                .await
                                .expect("why the rx closed?");
                        }
                        UbusMsg {
                            header:
                                UbusMsgHeader {
                                    cmd_type: UbusCmdType::HELLO,
                                    version: _,
                                    sequence: _,
                                    peer: _,
                                },
                            ubus_blobs: _,
                        } => {
                            println!(
                                "new connection to ubus got HELLO! my client_id is {:08x}",
                                message.header.peer
                            );
                        }
                        /*
                         * if server receive UbusCmdType::NOTIFY, it's ubus tell server that a client subscribers/unsubscribes
                         * client will receive a UbusCmdType::INVOKE if got notified
                         */
                        UbusMsg {
                            header:
                                UbusMsgHeader {
                                    cmd_type: UbusCmdType::NOTIFY,
                                    version: _,
                                    sequence: _,
                                    peer: _,
                                },
                            ubus_blobs: _,
                        } => {
                            log::info!(
                                "client {} try to {}",
                                if let Some(id) = message.get_attr_obj_id() {
                                    format!("{:08x}", id)
                                } else {
                                    "<UNKNOWN>".into()
                                },
                                if let Some(active) = message.get_attr_active() {
                                    if active { "subscribe" } else { "unsubscribe" }
                                } else {
                                    "<UNKNOWN>"
                                }
                            );
                        }
                        UbusMsg {
                            header:
                                UbusMsgHeader {
                                    cmd_type: _,
                                    version: _,
                                    sequence: seq,
                                    peer: _,
                                },
                            ubus_blobs: _,
                        } => {
                            let receiver = if let Some(receiver) =
                                reply_receivers_tx.lock().unwrap().get(&seq.into())
                            {
                                Some(receiver.clone())
                            } else {
                                None
                            };
                            if let Some(receiver) = receiver {
                                let _ = receiver.send(message).await.or_else(|e| {
                                        log::trace!("try to send to reply_receivers_rx[{}] but is dropped, rx may not care about messages any more", seq);
                                        Err(e)
                                    });
                            };
                        }
                    }
                }
            }
        };
        message_manager_receiver
    }
    fn run_message_manager_sender<W: AsyncIoWriter>(
        mut io_writer: W,
        mut message_sender_rx: mpsc::Receiver<UbusMsg>,
    ) -> impl Future<Output = Result<(), UbusError>> {
        let message_manager_sender = async move {
            loop {
                if let Some(message) = message_sender_rx.recv().await {
                    io_writer
                        .put(&message.to_bytes())
                        .await
                        .expect("why send failed")
                }
            }
        };
        message_manager_sender
    }
}
