use crate::*;

use core::{ops::Not, sync::atomic::AtomicU16};
use std::{collections::HashMap, format, string::ToString, sync::Arc, vec::Vec};
extern crate alloc;
use alloc::string::String;
use std::vec;
use storage_endian::BigEndian;
use tokio::{
    sync::{RwLock, mpsc},
    task::JoinSet,
};
use ubuserror::*;

#[derive(Copy, Clone)]
pub struct ObjectResult<'a> {
    pub path: &'a str,
    pub id: u32,
    pub ty: u32,
}
impl core::fmt::Debug for ObjectResult<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(f, "{} @0x{:08x} type={:08x}", self.path, self.id, self.ty)
    }
}

pub struct SignatureResult<'a> {
    pub object: ObjectResult<'a>,
    pub name: String,
    pub args: HashMap<String, BlobMsgType>,
}

#[derive()]
pub struct Connection {
    // io: T,
    /*
     * each connection has a client_id generated by ubus
     * in server mode,
     *      this is not used, instead server_obj_id is used
     * in client mode,
     *      this is what server see as a message.header.peer,
     *      but we don't need to set this, (we manually set it to server_obj_id), ubusd will set for us
     */
    // peer: u32,
    /*
     * in client mode,
     *      each request need a sequence to identify from other requests
     *      different client_obj (i.e. new connection) has different client_obj_id so it's okay to use same sequence
     *
     * // wrapped in arc so reference doesn't need to be mut
     * use AtomicU16 instead
     */
    sequence: AtomicU16,
    /*
     * not used, we use a heap allocated Vec to store received data
     */
    // buffer: [u8; 64 * 1024],
    /**
     * server_obj_id to UbusServerObject, mainly used to store the callbacks
     */
    server_objs: Arc<RwLock<HashMap<u32, UbusServerObject>>>,
    /**
     * (need redesign) if a UbusMsg is received from socket, the MassageManager will use the (peer, objid, seq) to identify which received to send
     * seq
     */
    reply_receivers_tx: Arc<RwLock<HashMap<u16, mpsc::Sender<UbusMsg>>>>,
    /**
     * should each server has its own channel?
     */
    // invoke_receiver_tx: mpsc::Sender<UbusMsg>,
    // invoke_receiver_rx: mpsc::Receiver<UbusMsg>,
    /**
     * send message to MessageManager and let it send to wire
     */
    message_sender_tx: mpsc::Sender<UbusMsg>,
    /**
     * run necessary loops in background, spawned in new(), aborted when dropped
     *  - invoke_handler    :   handle client's INVOKEs and call callbacks
     *  - message_manager   :   communicate with io (e.g. ubusd via UnixStream), dispatch messages through channels
     */
    communication_loops: JoinSet<()>,
}

impl Connection {
    /**
     * Create a new ubus connection from an existing IO
     *
     */
    pub async fn new<R: AsyncIoReader, W: AsyncIoWriter>(
        (io_reader, io_writer): (R, W),
    ) -> Result<Self, UbusError> {
        let (invoke_receiver_tx, invoke_receiver_rx) = mpsc::channel(8);
        let (message_sender_tx, message_sender_rx) = mpsc::channel(8);

        let mut conn = Self {
            // peer: 0,
            sequence: 0.into(),
            // buffer: [0u8; 64 * 1024],
            server_objs: Arc::new(RwLock::new(HashMap::new())),
            reply_receivers_tx: Arc::new(RwLock::new(HashMap::new())),
            // invoke_receiver_tx: invoke_receiver_tx.clone(),
            message_sender_tx: message_sender_tx.clone(),
            // invoke_handler: None,
            // message_manager: None,
            communication_loops: JoinSet::new(),
        };

        let reply_receivers_tx = conn.reply_receivers_tx.clone();
        /*
         * spawn and move the io to it makes it run forever, independent of how long the Connection struct lives
         */
        /* message manager */
        /* move io here */

        // conn.invoke_handler = Some(Box::new(invoke_handler));
        // conn.message_manager = Some(Box::new(message_manager));
        conn.communication_loops.spawn(Self::run_invoke_handler(
            conn.server_objs.clone(), /* clone the Arc */
            invoke_receiver_rx,
            message_sender_tx,
        ));
        conn.communication_loops.spawn(Self::run_message_receiver(
            io_reader,
            reply_receivers_tx,
            invoke_receiver_tx,
        ));
        conn.communication_loops
            .spawn(Self::run_message_sender(io_writer, message_sender_rx));

        // ubus server should say hello on connect
        // let message = conn.next_message().await?;

        // // Verify the header is what we expect
        // valid_data!(
        //     message.header.cmd_type == UbusCmdType::HELLO,
        //     "Expected hello"
        // );

        // Record our peer id
        // conn.peer = message.header.peer.into();

        Ok(conn)
    }

    /**
     * block forever.
     * this doesn't need to be call to run, loops are running in background when `new()`
     */
    pub async fn run(self) {
        self.communication_loops.join_all().await;
    }

    // fn header_by_obj_cmd(&mut self, obj_id: u32, cmd: UbusCmdType) -> UbusMsgHeader {
    //     UbusMsgHeader {
    //         version: UbusMsgVersion::CURRENT,
    //         cmd_type: cmd,
    //         sequence: self.generate_new_request_sequence(),
    //         peer: obj_id.into(),
    //     }
    // }

    // Get next message from ubus channel (blocking!)
    // pub async fn next_message(&mut self) -> Result<UbusMsg, UbusError> {
    //     // UbusMsg::from_io(&mut self.io).await
    //     // self.
    // }
    pub async fn send_message(&self, message: UbusMsg) -> Result<(), UbusError> {
        // self.io.put(&Into::<Vec<u8>>::into(message))
        // self.io.put(&message.to_bytes()).await
        self.message_sender_tx
            .send(message)
            .await
            .inspect_err(|_| log::warn!("failed to send because message_sender crashed!"))
            .map_err(|_| UbusError::UnexpectChannelClosed())
    }

    /**
     * call server with path + method + args
     *
     * same as `.lookup()` + `.invoke()`
     */
    pub async fn call(
        &self,
        server_obj_path: &str,
        method: &str,
        req_args: MsgTable,
    ) -> Result<MsgTable, UbusError> {
        let server_obj_id = self.lookup_id(server_obj_path).await?;
        self.invoke(server_obj_id, method, req_args).await
    }

    /**
     * call server with id + method + args
     *
     * `.invoke()` need a server_obj_id, which can be queried from `.lookup()`
     * if you don't need the id, just call `.call()`
     */
    pub async fn invoke(
        &self,
        server_obj_id: HexU32,
        method: &str,
        req_args: MsgTable,
    ) -> Result<MsgTable, UbusError> {
        match self
            .send_message_and_handle_reply(
                UbusCmdType::INVOKE,
                server_obj_id,
                vec![
                    UbusBlob::ObjId(server_obj_id),
                    UbusBlob::Method(method.to_string()),
                    UbusBlob::Data(req_args),
                ],
            )
            .await
        {
            /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
            Ok(ubus_blobs_list) => {
                let maybe_reply_args =
                    ubus_blobs_list
                        .into_iter()
                        .flatten()
                        .find_map(|ubus_blob| match ubus_blob {
                            UbusBlob::Data(d) => Some(d),
                            _ => None,
                        });
                if let Some(reply_args) = maybe_reply_args {
                    Ok(reply_args)
                } else {
                    Err(UbusError::InvalidData("response is empty"))
                }
            }
            Err(e) => Err(e),
        }
    }

    // pub fn lookup_object_json<'a>(&'a mut self, obj_path: &'a str) -> Result<String, UbusError> {
    //     serde_json::to_string_pretty(&self.lookup(obj_path)?.get(0))
    //         .map_err(|e| UbusError::InvalidData("Failed to stringify"))
    // }

    pub async fn lookup_id(&self, obj_path: &str) -> Result<HexU32, UbusError> {
        Ok(self
            .lookup(obj_path)
            .await?
            .get(0)
            .ok_or(UbusError::InvalidPath(obj_path.to_string()))?
            .id
            .into())
    }

    pub async fn lookup(&self, obj_path: &str) -> Result<Vec<UbusObject>, UbusError> {
        let reply = self
            .send_message_and_handle_reply(
                UbusCmdType::LOOKUP,
                0.into(),
                obj_path
                    .is_empty()
                    .not()
                    .then(|| UbusBlob::ObjPath(obj_path.to_string()))
                    .into_iter()
                    .collect(),
            )
            .await;
        match reply {
            Ok(ubus_blobs_list) => {
                let found_objs = ubus_blobs_list
                    .into_iter()
                    .map(|ubus_blobs| {
                        /*
                         * here the `obj` is inserted with some reference from `message`, then if we try to return it, rust ensure `message` should live longer than `obj`
                         * i check the code, message is a lot of slice to a global buffer in Connection, each time next_message() got called, the global buffer got overriden
                         */
                        let mut obj = UbusObject::default();
                        for ubus_blob in ubus_blobs {
                            match ubus_blob {
                                UbusBlob::ObjPath(path) => obj.path = path.to_string(),
                                UbusBlob::ObjId(id) => obj.id = id,
                                UbusBlob::ObjType(ty) => obj.objtype = ty,
                                UbusBlob::Signature(nested) => {
                                    obj.reported_signature = nested;
                                }
                                _ => {}
                            }
                        }
                        obj
                    })
                    .collect();
                Ok(found_objs)
            }
            Err(e) => Err(e),
        }
    }

    /*
     * ### When add_object
     * send:        add_object: {"objpath":"test","signature":{"hello":{"id":5,"msg":3},"watch":{"id":5,"counter":5},"count":{"to":5,"string":3}}}
     * return:      data:       {"objid":2013531835,"objtype":-1292016789}
     */

    /*
     * ### When handle INVOKE
     * server:
     * receive: invoke: {"objid":2013531835,"method":"hello","data":{"msg":"fsdfsdf"},"user":"fifv","group":"fifv"}
     * reply:   data:   {"objid":2013531835,"data":{"message":"test received a message: fsdfsdf"}}
     * reply:   status: {"status":0,"objid":2013531835}
     *
     * FIXME\: the read loop conflict with client read response after invoke
     *
     */

    /**
    Regsister a server object with obj_path, method_name and method_callbacks
      use a `UbusServerObjectBuilder` to build them

      the callback is auto wrapped in Arc to support closure capture

    TODO\: currently a `listening()` call is need to listen future requests, maybe I should find a better way


      ### Example
      ```
      let _ = connection
        .add_server(UbusServerObjectBuilder::new("t2").method(
            "hi",
            req_args: |&MsgTable| MsgTable::try_from(r#"{ "clo": "sure" }"#).unwrap(),
        ))
        .await
        .unwrap();
      ```

      ### Note
        Currently, if call `add_server` multiple times with same obj_path, ubusd will use latest one, and all objects' callbacks stored here, but only the latest objects'
        will be called by ubus, so memory leak happens
    */
    pub async fn add_server(
        &self,
        server_obj_builder: UbusServerObjectBuilder,
    ) -> Result<u32, UbusError> {
        // FIXME\: official ubus cli call stuck while data in monitor looks good <- fixed: replied seq should be same as requested
        let mut new_server_obj = {
            let reply = self
                .send_message_and_handle_reply(
                    UbusCmdType::ADD_OBJECT,
                    0.into(),
                    vec![
                        UbusBlob::ObjPath(server_obj_builder.path),
                        UbusBlob::Signature(
                            server_obj_builder
                                .methods
                                .iter()
                                .map(|(method, _)| BlobMsg {
                                    name: method.to_string(),
                                    data: BlobMsgPayload::Table(Vec::new()),
                                })
                                .collect::<Vec<BlobMsg>>()
                                .into(),
                        ),
                    ],
                )
                .await;
            match reply {
                Ok(ubus_blobs_list) => {
                    /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */
                    let mut new_server_obj: UbusServerObject = UbusServerObject::default();

                    for ubus_blob in ubus_blobs_list.into_iter().flatten() {
                        match ubus_blob {
                            UbusBlob::ObjId(id) => new_server_obj.id = id,
                            UbusBlob::ObjType(objtype) => new_server_obj.objtype = objtype,
                            _ => todo!(),
                        }
                    }
                    new_server_obj
                }
                Err(e) => return Err(e),
            }
        };

        new_server_obj.methods = server_obj_builder.methods;
        let new_server_obj_id = new_server_obj.id;
        self.server_objs
            .write()
            .await
            .insert(new_server_obj_id.into(), new_server_obj);
        Ok(new_server_obj_id.into())
    }

    /*
     *  ### When client subscribe
     * client send:     subscribe:  {"objid":1711030590}
     * server receive:  notify:     {"objid":130751756,"active":true}
     * client receive:  status:     {"status":0}
     *
     *  ### When client unsubscribe
     * server receive:  notify:     {"objid":130751756,"active":false}
     *
     *  ### When server notify
     */
    pub async fn notify(
        &self,
        server_obj_id: u32,
        method: &str,
        data: MsgTable,
    ) -> Result<(), UbusError> {
        /*
         *  ISSUE: the reply of notify is useless, but unlimited
         * it causes race and stuck sometimes... why?
         * â†‘ because I register callback after send_message(), so if reply is instant, the message manager get a message before
         * I register the receiver, and it doesn't find a receiver, just drop the message
         */

        // println!("3");

        /*
         * when server send a notify, it will receive:
         *      1.   STATUS without a Status::xxx - send to ubus successfully
         *      2..  STATUS with Status::OK - each successfully received client send one, infinitly
         *      2..  STATUS with Status::METHOD_NOT_FOUND - client may report this, but thats not we care about, only use as a debug
         *
         * After restruct, client's status is ignored at all
         */


        match self
            .send_message_and_handle_reply(
                UbusCmdType::NOTIFY,
                server_obj_id.into(),
                vec![
                    UbusBlob::ObjId(server_obj_id.into()),
                    UbusBlob::Method(method.into()),
                    UbusBlob::Data(data),
                ],
            )
            .await
        {
            /*
             * UbusBlob::Subscribers: only got this if no subscribers exist, with an empty MsgTable
             */
            Ok(_) => Ok(()),
            Err(e) => return Err(e),
        }
    }

    pub async fn subscribe(
        &self,
        listener_obj_id: HexU32,
        server_obj_id: HexU32,
    ) -> Result<(), UbusError> {
        match self
            .send_message_and_handle_reply(
                UbusCmdType::SUBSCRIBE,
                0.into(),
                vec![
                    UbusBlob::ObjId(listener_obj_id),
                    UbusBlob::Target(server_obj_id),
                ],
            )
            .await
        {
            Ok(_) => Ok(()),
            Err(e) => return Err(e),
        }
    }
}

/**
 * internally used
 */
impl Connection {
    /**
     * sequence is used to identify session, only client need to generate it, server should reply with same sequence with request's
     */
    fn generate_new_request_sequence(&self) -> BigEndian<u16> {
        // self.sequence = self.sequence.wrapping_add(1);
        // BigEndian::<u16>::from(self.sequence)

        /* also seems okay to use random number */
        // BigEndian::<u16>::from(random::<u16>(..))

        // let mut seq = self.sequence.lock().unwrap();
        // *seq = seq.wrapping_add(1);
        // BigEndian::<u16>::from(*seq)

        /* seems fetch_add can wrapping */
        let seq = self
            .sequence
            .fetch_add(1, core::sync::atomic::Ordering::Relaxed)
            .wrapping_add(1);
        BigEndian::<u16>::from(seq)
    }

    /**
     * a dedicated task to handle all INVOKEs from client, call callbacks, and reply
     *
     * this is spawned and ignored, currently it panic if some weird happens
     */
    async fn run_invoke_handler(
        server_objs: Arc<RwLock<HashMap<u32, UbusServerObject>>>,
        mut invoke_receiver_rx: mpsc::Receiver<UbusMsg>,
        message_sender_tx: mpsc::Sender<UbusMsg>,
    ) {
        /* FIXME: it may be not ideal to abuse ? to throw error, each error should be handled correctly */
        // let server_objs_map = HashMap::<u32, UbusServerObject>::from_iter(
        //     server_objs.into_iter().map(|obj| (obj.id, obj)),
        // );
        /* Normally we will get a UbusCmdType::DATA then a UbusCmdType::STATUS */

        loop {
            let message = invoke_receiver_rx
                .recv()
                .await
                .expect("failed to receive because message_receiver crashed!");

            /* only INVOKE should reach here, is this syntax more readable than if let? */
            let UbusCmdType::INVOKE = message.header.cmd_type else {
                log::warn!(
                    "invoke_handler got a non-INVOKE message {:?}, which is not expected",
                    &message
                );
                continue;
            };

            /*
             * server object normally won't got a status, instead, server will send back a status OK to terminate client
             */
            /*
             * client's INVOKE contains:
             *      - `message.header.peer`         : the client's obj_id, should be used as `message.header.peer` when reply
             *      - `message.header.sequence`     : used to identify current session, should be used as `message.header.sequence` when reply
             *      - `message.ubus_blobs.?.ObjId`  : current server obj_id, should be used as `message.ubus_blobs.?.ObjId` when reply.
             *                                        this is same as the response from add_server
             *      - `message.ubus_blobs.?.Method` : client want to call this method
             *      - `message.ubus_blobs.?.Data`   : client requested with this json
             */
            // TODO: use Option
            let Some((requested_server_obj_id, method_name, req_args)) = ({
                let mut requested_server_obj_id = None;
                let mut method_name = None;
                let mut req_args = None;
                for blob in message.ubus_blobs {
                    // dbg!(&blob);
                    match blob {
                        UbusBlob::ObjId(id) => requested_server_obj_id = Some(id),
                        UbusBlob::Method(method) => method_name = Some(method),
                        UbusBlob::Data(msg_table) => req_args = Some(msg_table),
                        _ => {}
                    }
                }
                match (requested_server_obj_id, method_name, req_args) {
                    (Some(requested_server_obj_id), Some(method_name), Some(req_args)) => {
                        Some((requested_server_obj_id, method_name, req_args))
                    }
                    _ => None,
                }
            }) else {
                log::warn!(
                    "invoke_handler can't get obj_id, method_name, and req_args from INVOKE"
                );
                continue;
            };


            enum FindMethodStatus {
                Found(UbusMethod),
                ObjectNotFound,
                MethodNotFound,
            }
            // tokio::runtime::Runtime::new().unwrap().block_on(async {});

            /* reply to client */

            /*
             * try to get the method from the HashMap, clone the method Arc, then drop the sync::Mutex
             * if we doesn't drop the Mutex,
             *      1. it can't be Send, compiler errors
             *      2. if the callback takes time, the callbacks HashMap is locked, and other callbacks can't get called
             */
            let find_method_result = if let Some(server_obj) = server_objs
                .read()
                .await
                .get(&requested_server_obj_id.into())
            {
                match server_obj.methods.get(&method_name) {
                    Some(method) => FindMethodStatus::Found(method.clone()),
                    None => FindMethodStatus::MethodNotFound,
                }
            } else {
                FindMethodStatus::ObjectNotFound
            };

            /* use a dedicated task to run the callback */
            // FIXME\: the unwrap may panic
            let message_sender_tx = message_sender_tx.clone();
            tokio::spawn(async move {
                match find_method_result {
                    FindMethodStatus::Found(method) => {
                        // tokio::spawn(async {});
                        let reply_args = method(&req_args);
                        /* here client_obj_id == server objid */
                        message_sender_tx
                            .send(UbusMsg {
                                header: UbusMsgHeader {
                                    version: UbusMsgVersion::CURRENT,
                                    cmd_type: UbusCmdType::DATA,
                                    sequence: message.header.sequence,
                                    peer: message.header.peer,
                                },
                                ubus_blobs: vec![
                                    UbusBlob::ObjId(requested_server_obj_id),
                                    /* data is moved to enum, then moved to UbusMsg */
                                    UbusBlob::Data(reply_args),
                                ],
                            })
                            .await
                            .inspect_err(|_| {
                                log::warn!(
                                    /* idk why but too long cause fmt broken */
                                    "failed to send reply because the message_receiver is down"
                                )
                            })
                            .ok();

                        // dbg!(reply_args);

                        // sleep(Duration::from_millis(400));

                        message_sender_tx
                            .send(UbusMsg {
                                header: UbusMsgHeader {
                                    version: UbusMsgVersion::CURRENT,
                                    cmd_type: UbusCmdType::STATUS,
                                    sequence: message.header.sequence,
                                    peer: message.header.peer,
                                },
                                ubus_blobs: vec![
                                    UbusBlob::ObjId(requested_server_obj_id),
                                    UbusBlob::Status(UbusMsgStatus::OK),
                                ],
                            })
                            .await
                            .inspect_err(|_| {
                                log::warn!(
                                    "failed to send reply because the message receiver is down"
                                )
                            })
                            .ok();
                    }
                    FindMethodStatus::MethodNotFound => {
                        /* method not found */
                        message_sender_tx
                            .send(UbusMsg {
                                header: UbusMsgHeader {
                                    version: UbusMsgVersion::CURRENT,
                                    cmd_type: UbusCmdType::STATUS,
                                    sequence: message.header.sequence,
                                    peer: message.header.peer,
                                },
                                ubus_blobs: vec![
                                    UbusBlob::ObjId(requested_server_obj_id),
                                    UbusBlob::Status(UbusMsgStatus::METHOD_NOT_FOUND),
                                ],
                            })
                            .await
                            .inspect_err(|_| {
                                log::warn!(
                                    "failed to send reply because the message_receiver is down"
                                )
                            })
                            .ok();
                    }
                    FindMethodStatus::ObjectNotFound => {
                        /* server obj not found */
                        message_sender_tx
                            .send(UbusMsg {
                                header: UbusMsgHeader {
                                    version: UbusMsgVersion::CURRENT,
                                    cmd_type: UbusCmdType::STATUS,
                                    sequence: message.header.sequence,
                                    peer: message.header.peer,
                                },
                                ubus_blobs: vec![
                                    UbusBlob::ObjId(requested_server_obj_id),
                                    UbusBlob::Status(UbusMsgStatus::NOT_FOUND),
                                ],
                            })
                            .await
                            .inspect_err(|_| {
                                log::warn!(
                                    "failed to send reply because the message_receiver is down"
                                )
                            })
                            .ok();
                    }
                }
            });
        }
    }

    /**
     * message_manager, previously i combine them with tokio::select(), but i don' know is it safe,
     * as the select docs says read_exact and write_all are not cancellation safe and can lead to loss of data
     */
    async fn run_message_receiver<R: AsyncIoReader>(
        mut io_reader: R,
        reply_receivers_tx: Arc<RwLock<HashMap<u16, mpsc::Sender<UbusMsg>>>>,
        invoke_receiver_tx: mpsc::Sender<UbusMsg>,
    ) {
        loop {
            UbusMsg::from_io(&mut io_reader).await.ok();
            let Ok(message) = UbusMsg::from_io(&mut io_reader).await else {
                panic!(
                    "failed to read from io, maybe ubusd got shutdown? {}",
                    std::io::Error::last_os_error()
                );
            };


            // dbg!(&message);
            log::trace!("got message: {:?}", &message);
            match message.header.cmd_type {
                UbusCmdType::INVOKE => {
                    invoke_receiver_tx
                        .send(message)
                        .await
                        .expect("failed to send because invoke_handler crashed!");
                }
                UbusCmdType::HELLO => {
                    log::trace!(
                        "new connection to ubus got HELLO! my client_id is {:08x}",
                        message.header.peer
                    );
                }
                /*
                 * if server receive UbusCmdType::NOTIFY, it's ubus tell server that a client subscribers/unsubscribes
                 * client will receive a UbusCmdType::INVOKE if got notified
                 */
                UbusCmdType::NOTIFY => {
                    log::info!(
                        "client {} try to {}",
                        if let Some(id) = message.get_attr_obj_id() {
                            format!("{:08x}", id)
                        } else {
                            "<UNKNOWN>".into()
                        },
                        if let Some(active) = message.get_attr_active() {
                            if active { "subscribe" } else { "unsubscribe" }
                        } else {
                            "<UNKNOWN>"
                        }
                    );
                }
                /*
                 *
                 */
                UbusCmdType::STATUS | UbusCmdType::DATA => {
                    let seq = message.header.sequence;
                    let receiver =
                        if let Some(receiver) = reply_receivers_tx.read().await.get(&seq.into()) {
                            Some(receiver.clone())
                        } else {
                            None
                        };
                    if let Some(receiver) = receiver {
                        let _ = receiver.send(message).await
                            .inspect_err(|e| {
                                log::trace!("try to send to reply_receivers_rx[{}] but is dropped, rx may not care about messages any more", seq);
                            });
                    };
                }
                _ => {
                    log::warn!(
                        "receive a message which doesn't know how to handle: {:?}",
                        &message
                    );
                }
            }
        }
    }
    async fn run_message_sender<W: AsyncIoWriter>(
        mut io_writer: W,
        mut message_sender_rx: mpsc::Receiver<UbusMsg>,
    ) {
        loop {
            if let Some(message) = message_sender_rx.recv().await {
                io_writer
                    .put(&message.to_bytes())
                    .await
                    .expect("failed to send to IO, maybe ubusd got shutdown?")
            } else {
                panic!("failed to recv, maybe connection struct got dropped?");
            }
        }
    }
    async fn send_message_and_handle_reply(
        &self,
        request_cmd_type: UbusCmdType,
        request_peer: HexU32,
        request_blobs: Vec<UbusBlob>,
    ) -> Result<Vec<Vec<UbusBlob>>, UbusError> {
        let new_request_sequence = self.generate_new_request_sequence();
        let (reply_receiver_tx, mut reply_receiver_rx) = mpsc::channel::<UbusMsg>(4);
        self.reply_receivers_tx
            .write()
            .await
            .insert(new_request_sequence.into(), reply_receiver_tx);

        self.send_message(UbusMsg {
            header: UbusMsgHeader {
                version: UbusMsgVersion::CURRENT,
                cmd_type: request_cmd_type,
                sequence: new_request_sequence,
                peer: u32::from(request_peer).into(),
            },
            ubus_blobs: request_blobs,
        })
        .await?;

        let mut data_blobs = Vec::with_capacity(2);
        let status = 'messages: loop {
            if let Some(message) = reply_receiver_rx.recv().await {
                match message.header.cmd_type {
                    UbusCmdType::STATUS => {
                        /*
                         * remove the channel to save memory, e.g. channel(8) x 65535 consume ~100MB
                         */
                        self.reply_receivers_tx
                            .write()
                            .await
                            .remove(&new_request_sequence.into());

                        for blob in message.ubus_blobs {
                            match blob {
                                UbusBlob::Status(UbusMsgStatus::OK) => {
                                    break 'messages Ok(());
                                }
                                UbusBlob::Status(status) => {
                                    break 'messages Err(UbusError::Status(status));
                                }
                                /* when NOTIFY, the response by ubusd doesn't contain a Status... wtf */
                                _ => break 'messages Ok(()),
                            }
                        }
                        // break 'messages Err(UbusError::InvalidData("Invalid status message"));
                    }
                    UbusCmdType::DATA => {
                        data_blobs.push(message.ubus_blobs);
                        // break 'messages Err(UbusError::InvalidData("Invalid data message"));
                    }
                    _ => {
                        log::warn!(
                            "receive a message which doesn't know how to handle: {:?}",
                            &message
                        );
                    }
                }
            } else {
                log::warn!("the reply_receiver_tx disappears?! this shouldn't happen!")
            };
        };
        match status {
            Ok(_) => Ok(data_blobs),
            Err(e) => Err(e),
        }
    }
}
