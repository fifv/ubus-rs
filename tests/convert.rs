#[cfg(test)]

/**
 * Generated by copilot, TODO: check later
 */
mod tests {
    use ubus::{Blob, BlobBuilder, BlobIter, BlobTag, UbusBlob, UbusBlobType};

    use super::*;
    use core::convert::TryFrom;

    #[test]
    fn blobtag_basic_properties() {
        // build a non-extended tag with id=5 and len=12
        let tag = BlobTag::try_build(5, 12, false).expect("build tag");
        assert_eq!(tag.blob_type(), 5);
        assert_eq!(tag.size(), 12);
        assert!(!tag.is_extended());

        // padding and next_tag should be consistent with ALIGNMENT
        let padded = tag.next_tag();
        let expected_padding = BlobTag::ALIGNMENT.wrapping_sub(tag.size()) & (BlobTag::ALIGNMENT - 1);
        assert_eq!(tag.padding(), expected_padding);
        assert_eq!(padded, tag.size() + expected_padding);

        // roundtrip to/from bytes
        let bytes = tag.to_bytes();
        let parsed = BlobTag::from_bytes(&bytes);
        assert_eq!(parsed, tag);
    }

    #[test]
    fn ubusblob_string_roundtrip() {
        // create a OBJPATH string blob and parse it back
        let name = "hello-world";
        let builder = BlobBuilder::from_str(UbusBlobType::OBJPATH.value(), name)
            .expect("build objpath blob");
        // verify tag metadata matches buffer
        let tag_bytes: [u8; BlobTag::SIZE] = builder.to_bytes_clone()[..BlobTag::SIZE].try_into().unwrap();
        let tag = BlobTag::from_bytes(&tag_bytes);
        assert_eq!(tag.size(), BlobTag::SIZE + name.len() + 1); // header + nul byte

        // parse as UbusBlob
        let ub =
            UbusBlob::try_from(builder.to_bytes_clone().as_slice()).expect("parse ubus blob from bytes");
        match ub {
            UbusBlob::ObjPath(s) => assert_eq!(s, name),
            other => panic!("unexpected variant: {:?}", other),
        }
    }

    #[test]
    fn ubusblob_u32_and_iter_multiple() {
        // build two blobs: OBJID (numeric) and OBJPATH (string)
        let id_value: u32 = 0x2a;
        let b1 = BlobBuilder::from_u32(UbusBlobType::OBJID.value(), id_value)
            .expect("build objid");
        let path = "svc/example";
        let b2 = BlobBuilder::from_str(UbusBlobType::OBJPATH.value(), path)
            .expect("build objpath");

        // concatenate buffers as a stream and iterate
        let mut stream = Vec::new();
        stream.extend_from_slice(&b1.to_bytes_clone());
        stream.extend_from_slice(&b2.to_bytes_clone());

        let mut iter = BlobIter::new(&stream);
        let first = iter.next().expect("first blob");
        match first {
            Blob::UbusBlob(UbusBlob::ObjId(v)) => {
                // BlobBuilder wrote a u32 payload; UbusBlob parses into i32 -> compare by bit pattern
                assert_eq!(v as i64 as u32, id_value);
            }
            other => panic!("unexpected first variant: {:?}", other),
        }

        let second = iter.next().expect("second blob");
        match second {
            Blob::UbusBlob(UbusBlob::ObjPath(s)) => {
                assert_eq!(s, path);
            }
            other => panic!("unexpected second variant: {:?}", other),
        }

        // no more blobs
        assert!(iter.next().is_none());
    }

    #[test]
    fn blobbuilder_tag_next_tag_matches_buffer_len() {
        // small string to force some padding maybe
        let builder = BlobBuilder::from_str(UbusBlobType::METHOD.value(), "x")
            .expect("build method blob");
        let buf_len = builder.to_bytes_clone().len();
        let tag_bytes: [u8; BlobTag::SIZE] = builder.to_bytes_clone()[..BlobTag::SIZE].try_into().unwrap();
        let tag = BlobTag::from_bytes(&tag_bytes);
        // next_tag should correspond to the total padded size written to the buffer
        assert_eq!(tag.next_tag(), buf_len);
    }
}